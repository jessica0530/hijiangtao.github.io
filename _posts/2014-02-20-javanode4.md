---
date: 2014-02-20
layout: post
title: Java学习笔记-类与对象
thread: 44
categories: 文档
tags: java
---

##第五章 对象和类

* **基本概念**

 1. 封装：a.隐藏信息; b.使方法的实现细节不可见; c.统一对所有用户的接口; d.提高效率;
 2. 继承：通过已有的类去扩展新的类。
 3. 多态：同一类域的不同对象在调用相同方法的时候表现不同的现象(针对对象的行为而言）。
    
     
* **方法定义格式**

 1. <modifiers>：访问修饰符（可以为若干个），没有先后顺序。例如public static,static public,private等。
 2. <return_type>：方法的返回值类型（表示函数的出口），一个方法没有返回值时就必须定义为void，构造方法没有返回类型。
 3. <name>：方法名，方法名表示方法在代码区当中的地址。
 4. ([<argument_list>])：参数列表（表示函数的入口），可选。
 5. [throw<exception>]：声明抛出的异常类型，可选。
 6. {<block>}:方法体（即方法中的执行的代码）。
     
```
<modifiers><return_type><name>([argument_list>])[throws <exception>]{<block>}
```
    
    
* **参数传递方式**：按值传递和按引用传递
    
    
* **this关键字**：当前对象的引用
    
 1. 当局部变量和实例变量出现命名冲突时，Java中表现为就近原则，因而java处理这种现象是使用`this.variableName`表示实例变量；
 2. 两种用法：
(1) this.variableName（实例变量） ---> 用于区分同名的实例变量和局部变量；
(2) this（参数列表） ---> 用于调用本类的构造器。
 3. 在构造器中this()必须放在方法的第一行；
 4. this是个隐式参数，代表被构造的对象；

```
public class Person{
    private String name;
    public void setName(String name){
        this.name=name; // this.name为实例变量
    }
}
```
    
    
* **封装**
    
 1. 数据隐藏（信息隐藏）：private修饰符。类的编写者可以控制类的信息访问者（或类的使用者）的行为；当一个类的内部信息的表达方式发生变化时，它不会影响类的使用者。
 2. 方法的重载条件：1).方法名必须相同（在同一类中有若干个方法相同）；2).参数列表必须不同：表现在(1)参数个数不同, (2)参数类型不同, (3)参数顺序不同；3).返回类型无关紧要(返回值类型是否相同对重载没有任何的影响)；4).Overloading方法对于不匹配的参数是从低向高转换的:Byte—short—int—long—
float—double。
    
* **继承**
    
    
1. 条件：必须满足“is a”关系才可以继承；
2. 语法：pulic class subclass extends superclass{...}；
3. 单根继承：不允许多重继承；一个子类只能有一个父类，但一个父类可以有若干个子类；JAVA中所有类都有一个祖先类Object（没有父类）；
4. 父类中的构造器不能继承，但可以被调用；方法和成员变量都可以被继承；
5. Super关键字: 表示父类数据区的引用.super是隐形参数，代表被构造对象的父类；其必须在构造器的第一行。就两种用法：

     ①调用父类构造器：作为子类中的任何一个构造器必须调用父类中的构造器，表现为a.显式调用：“super（传递给父类的参数值）”调用父类构造器并对其属性进行初始化，且必须放在构造器的第一行；b.隐式调用：如果在子类构造器中省略调用父类构造器的语法，则编译器将自动插入代码super()默认调用父类的无参构造器，如果父类中不存在无参构造器的话，系统将会显示编译出错。
     
      ②调用父类中的变量或方法：“super.父类的方法名（）”调用父类中同名的方法（当子类中含有与调用父类方法同名的方法时必须加“super.”，否则不用）。
6. 弊端: 减少了代码的灵活性；破坏了耦合性原则——低耦合，高内聚。

* **多态**

1. 概念：不同类型的对象虽然是相同的操作但执行的是不同的过程；
2. 注意：对象的类型永远所固定的；
3. 操作符 instanceof:返回结果是boolean型；
4. 转换：**上朔造型**：将子类类型变量转换成父类类型变量是隐式的；**下朔造型**：将父类类型转换成类类型是显式的(强制转换前需利用instanceof对其进行类型鉴定)；**显式转换成功的前提条件**是被转换的变量所指向的对象类型一定要是转换以后类型的自身或者是它的子类。
5. 方法覆盖（Methods Overridden，也叫方法重写）：**范围**在父类与子类之间。**条件**：具有相同的方法名，相同的参数列表和相同的返回类型；可见范围不能被缩小（private为最小的可见范围，public为最大的可见范围，
默认可见范围是位于二者之间的）；
6. 多态的三种表现形式：

```
/*以下均为伪代码*/
父类 引用 = new 子类();
接口 引用 = new 实现类();

方法声明 public void method(父类 参数){};
方法调用 method(new 子类());

public 父类 method(){
    return new 子类():
}
```

* **面向对象与面向过程**

面向过程是先有算法，后有数据结构；面向对象是先有数据结构，然后再有算法。