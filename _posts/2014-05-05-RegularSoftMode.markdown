---
date: 2014-05-05 23:00:00
layout: post
title: 软件开发常见的五种设计模式
thread: 117
categories: 文档
tags: 设计模式
---

**前言：**虽然说是常见的设计模式，但是却没有说到经典的工厂模式，本文的叙述内容大体是按照我们小组在Aspectj研究中对设计模式的匹配结果来进行叙述的，为了凝练我们小组在设计模式上的研究成果，罗列以下五种设计模式与大家一起分享。

----

##一、单例模式

模式三要素

* 私有的构造方法
* 指向自己实例的私有静态引用
* 以自己实例为返回值的静态的公有的方法

单例模式根据实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。

单例模式的优点

* 在内存中只有一个对象，节省内存空间
* 避免频繁的创建销毁对象，可以提高性能
* 避免对共享资源的多重占用
* 可以全局访问

**适用场景：**由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。

我总结了一下我所知道的适合使用单例模式的场景：

* 需要频繁实例化然后销毁的对象。
* 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
* 有状态的工具类对象。
* 频繁访问数据库或文件的对象。
* 以及其他我没用过的所有要求只有一个对象的场景。

----

##二、观察者模式

**设计意图：**在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系，从而实现软件体系结构的松耦合。

他定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。

**观察者模式完美的将观察者和被观察的对象分离开。**在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。

**解除耦合。**让耦合的双方都依赖抽象而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。

**拍卖例子：**观察者定义了对象间一对多的关系，当一个对象的状态变化时，所有依赖它的对象都得到通知并且自动地更新。拍卖演示了这种模式。每个投标人都有一个标有数字的牌子用于出价。拍卖师开始拍卖时，他观察是否有牌子举起出价。每次接受一个新的出价都改变了拍卖的当前价格，并且广播给所有的投标人进行新的出价。

----

##三、原型模式

使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。[复制已有实例]

原型模式的主要思想是基于现有的对象克隆一个新的对象出来，一般是有对象的内部提供克隆的方法，通过该方法返回一个对象的副本。

**例子：**配钥匙

原型模型涉及到三个角色：

**客户角色（client）：**客户端提出创建对象的请求；
**抽象原型（prototype）：**这个往往由接口或者抽象类来担任，给出具体原型类的接口；
**具体原型（Concrete prototype）：**实现抽象原型，是被复制的对象； 

----

##四、策略模式

在软件开发中也常常遇到类似的情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。

如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？

定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。也称为政策模式(Policy)。

**优点：**

1. 策略模式提供了管理相关的算法的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。

2. 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。继承有助于析取出这些算法中的公共功能。

3. 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。

**缺点：**

1. 策略模式只适用于客户端知道所有的算法或行为的情况。因为客户端必须知道所有的策略类，并自行决定使用哪一个策略类。所以客户端必须理解这些算法的区别，以便适时选择恰当的算法类。

2. 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。

----

##五、代理模式

**作用：**为其他对象提供一种代理以控制对这个对象的访问。

**好处：**在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

代理模式一般涉及到的角色有：

**抽象角色**：声明真实对象和代理对象的共同接口； 

**代理角色**：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装；

**真实角色**：代理角色所代表的真实对象，是我们最终要引用的对象。
