---
date: 2014-03-08 10:00:00
layout: post
title: OpenGL学习笔记8：透明纹理效果
thread: 69
categories: 教程
tags: OpenGL
---

前言：在老师的推荐下准备系统学习下Nehe关于OpenGL的教程，在打开chm的第一眼就被作者的开源奉献精神所深深打动，这种思想与我不谋而合。

以下内容为我学习了教程之后自己的操作与总结，由于硬件与软件环境的差异，我的笔记内容在代码和描述上与原文可能存在一定出路。

----

本笔记记录的内容包括：在纹理的基础上添加了透明混合，可以通过按键B控制透明效果的开/关。

----

##简单的透明

OpenGL中的绝大多数特效都与某些类型的(色彩)混合有关。混色的定义为，将某个象素的颜色和已绘制在屏幕上与其对应的象素颜色相互结合。至于如何结合这两个颜色则依赖于颜色的alpha通道的分量值，以及所使用的混色函数。Alpha通常是位于颜色值末尾的第4个颜色组成分量。前面学习的时候一直是用GL_RGB来指定颜色的三个分量。相应的GL_RGBA可以指定alpha分量的值。进一步，现在可以使用glColor4f()来代替glColor3f()。

绝大多数人都认为Alpha分量代表材料的透明度。这就是说，alpha值为0.0时所代表的材料是完全透明的。alpha值为1.0时所代表的材料则是完全不透明的。 

##混合公式

(Rs Sr + Rd Dr, Gs Sg + Gd Dg, Bs Sb + Bd Db, As Sa + Ad Da)

OpenGL按照上面的公式计算这两个象素的混色结果。小写的s和r分别代表源象素和目标象素。大写的S和D则是相应的混色因子。这些决定了您如何对这些象素混色。绝大多数情况下，各颜色通道的alpha混色值大小相同，这样对源象素就有 (As, As, As, As)，目标象素则有1, 1, 1, 1) - (As, As, As, As)。上面的公式就成了下面的模样:

(Rs As + Rd (1 - As), Gs As + Gd (1 - As), Bs As + Bs (1 - As), As As + Ad (1 - As))

这个公式会生成透明/半透明的效果。

##OpenGL中的混色

正确的混色过程应该是先绘制全部的场景之后再绘制透明的图形。并且要按照与深度缓存相反的次序来绘制(先画最远的物体)。

考虑对两个多边形(1和2)进行alpha混合，不同的绘制次序会得到不同的结果。(这里假定多边形1离观察者最近，那么正确的过程应该先画多边形2，再画多边形1。正如您再现实中所见到的那样，从这两个<透明的>多边形背后照射来的光线总是先穿过多边形2，再穿过多边形1，最后才到达观察者的眼睛。)

在深度缓存启用时，您应该将透明图形按照深度进行排序，并在全部场景绘制完毕之后再绘制这些透明物体。否则您将得到不正确的结果。我知道某些时候这样做是很令人痛苦的，但这是正确的方法。

----

在笔记7代码的基础上，先在代码开始处增加两个新的变量。

```
bool    blend;					// 是否混合?
bool	bp;						// B 键按下了么?
```

然后往下移动到 LoadGLTextures() 这里。找到" if (TextureImage[0]=LoadBMP("1.bmp")) "这一行。现在使用有色玻璃纹理来代替上一课中的木箱纹理。

```
if (TextureImage[0]=LoadBMP("2.bmp"))	// 载入玻璃位图
```

在InitGL()代码段加入以下两行。第一行以全亮度绘制此物体，并对其进行50%的alpha混合(半透明)。当混合选项打开时，此物体将会产生50%的透明效果。第二行设置所采用的混合类型。

```
glColor4f(1.0f,1.0f,1.0f,0.5f);		// 全亮度， 50% Alpha 混合
glBlendFunc(GL_SRC_ALPHA,GL_ONE);	// 基于源象素alpha通道值的半透明混合函数
```

找到代码段

```
if (keys[VK_LEFT])				// Left方向键按下了么?
{
	yspeed-=0.01f;				// 若是, 减少yspeed 
}
```

在其后面填上：

```
if (keys['B'] && !bp)				// B 健按下且bp为 FALSE么?
{
	bp=TRUE;				// 若是， bp 设为 TRUE
	blend = !blend;				// 切换混合选项的 TRUE / FALSE
	if(blend)				// 混合打开了么?
	{
		glEnable(GL_BLEND);		// 打开混合
		glDisable(GL_DEPTH_TEST);	// 关闭深度测试
	}
	else					// 否则
	{
		glDisable(GL_BLEND);		// 关闭混合
		glEnable(GL_DEPTH_TEST);	// 打开深度测试
	}
}
if (!keys['B'])					//  B 键松开了么?
{
	bp=FALSE;				// 若是， bp设为 FALSE
}
```

这几行监视B键是否按下。如果是的话，计算机检查混合选项是否已经打开。然后将其置为相反的状态。

本例代码：[下载地址](/code/DataBlog_OpenGLObjectLucency.cpp)

----

最后，如果你也对OpenGL感兴趣或者你在学习中有任何想法，欢迎在下方留言、与我交流！祝愿我们共同成长、一起进步！